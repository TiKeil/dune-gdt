% ==================================================================================================================== %
% dune-functionals.tex
% by: Felix Albrecht (felix.albrecht@uni-muenster.de)
% ==================================================================================================================== %
\documentclass[a4paper,11pt]{article}

% required packages and definitions
\usepackage[utf8]{inputenc}
%% \usepackage[body={148mm,240mm,nohead}]{geometry}

\usepackage{multicol}
\usepackage{xspace}
\usepackage{relsize}

\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{epsfig}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\numberwithin{equation}{section}
\newtheorem{definition}{Definition}[section]
\newtheorem{class}[definition]{Class}
\newtheorem{remark}[definition]{Remark}
\newtheorem{example}[definition]{Example}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{problem}[definition]{Problem}
\newtheorem{disclaimer}[definition]{Disclaimer}
\newcommand{\theoremNewline}{\hspace{1mm}\\}
\newcommand{\theoremEndLine}{\hspace{1mm}}
\newcommand{\theoremItemizeNewline}{\hspace{1mm}\vspace{-3mm}}

\usepackage{hyperref}
\usepackage{url}

\usepackage{longtable}
\usepackage{listings}
\lstset{language=C++,
basicstyle=\ttfamily\color{black}\footnotesize,
keywordstyle=\underbar,
identifierstyle=,
commentstyle=\color{blue},
stringstyle=\itshape\color{green},
numbers=left,
numberstyle=\tiny}
\newcommand{\Code}[1]{\texttt{#1}}
\newcommand{\code}[1]{\lstinline!#1!}
\newcommand{\CodeT}[1]{\textnormal{\texttt{#1}}}
\newcommand{\codeT}[1]{\textnormal{\lstinline!#1!}}

\usepackage{tikz}
\usepgflibrary{arrows}

\newcommand{\dune}{\textsc{Dune}\xspace}
% \newcommand{\dunecommon}{\textsc{Dune-Common}\xspace}
% \newcommand{\dunegrid}{\textsc{Dune-Grid}\xspace}
% \newcommand{\duneistl}{\textsc{Dune-Istl}\xspace}
% \newcommand{\dunelocalfunctions}{\textsc{Dune-Localfunctions}\xspace}

\newcommand{\dunefem}{\textsc{Dune-Fem}\xspace}
\newcommand{\dunefunctionals}{\textsc{Dune-Functionals}\xspace}
\newcommand{\dunepdelab}{\textsc{Dune-PDELab}\xspace}
% \newcommand{\dumux}{\textsc{DuMu}$^\textrm{x}$\xspace}

% \newcommand{\alugrid}{\textsc{ALUGrid}\xspace}
% \newcommand{\alberta}{\textsc{ALBERTA}\xspace}

% \newcommand{\albertagrid}{{\tt AlbertaGrid}\xspace}
% \newcommand{\alusimplexgrid}{{\tt ALUSimplexGrid}\xspace}
% \newcommand{\alucubegrid}{{\tt ALUCubeGrid}\xspace}
% \newcommand{\aluconformgrid}{{\tt ALUConformGrid}\xspace}
% \newcommand{\uggrid}{{\tt UGGrid}\xspace}
% \newcommand{\onedgrid}{{\tt OneDGrid}\xspace}
% \newcommand{\sgrid}{{\tt SGrid}\xspace}
% \newcommand{\yaspgrid}{{\tt YaspGrid}\xspace}

\newcommand{\hnS}{\hspace{-1.25pt}}
\newcommand{\divergence}{\nabla\hnS\hnS\hnS\cdot}
\newcommand{\gradient}{\nabla\hnS\hnS}
\newcommand{\boundary}{\partial \hnS}
\newcommand{\dx}{\;d\hnS x}
\newcommand{\komma}{\text{,}}
\newcommand{\punkt}{\text{.}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Tau}{\mathcal{T}}

\title{\dunefunctionals}
\author{Felix Albrecht (\Code{felix.albrecht@uni-muenster.de})}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
	This document is a draft about a new \dune discretization module, based on \dunefem and \dunepdelab.
\end{abstract}

\hrule

\begin{small}
	\tableofcontents
\end{small}

\vspace{5mm}
\hrule


\section{Introduction}
	\label{section::introduction}


\begin{disclaimer}\theoremNewline
	\label{disclaimer::introduction}
	Everything presented in this document is in a very early state of development! The presented ideas, concepts and
	implementation details will possibly be subject to significant change in the future. In particular any implementation
	specific details, like interfaces, method signatures, reference vs. smart pointer usage, etc is completely neglected in
	this draft.
\end{disclaimer}\theoremEndLine

The overall goal of \dunefunctionals is the efficient numerical solution of PDE's. To make our intentions clearer,
here is a short introduction to our ``philosophy''.

\begin{remark}[Philosophy behind \dunefunctionals]
We had the following in mind, when we started to design \dunefunctionals:
  \begin{itemize}
    \item By \textquotedblleft efficient\textquotedblright we mainly have the efficiency of the programmer in mind, without sacrificing too much of the efficiency of the program.
    \item Things should be simple. There should be no \textquotedblleft eierlegende Wollmilchsau\textquotedblright.
    \item Code is usually more often read than written. Write it readable.
    \item Everything should be highly modularized, where each piece serves a small but distinct purpose.
  \end{itemize}
  In the end, there should also be an additional \dune module to bundle together the above mentioned pieces with
  suitable defaults for teaching, lazy users and quick and simple solutions.
\end{remark}

One result of these principles is the following.

\begin{remark}[Branches]
  Everything new is created in a seperate (testing-) branch or repository. Only code, that complies to the above philosophy
  is merged into trunk/master.
\end{remark}

In addition to this philosophy there are some other principles that are constitutive for \dunefunctionals.

\begin{definition}[Design principles of \dunefunctionals]\theoremItemizeNewline
  \begin{itemize}
    \item There should be persistent grid views (C.E. and F.A. already did some thinking on this).
    \item There should be discrete function spaces that do not change during runtime.
    \item There should be discrete functions, whose size do not change during runtime.
    \item Adaptivity is realized by creating a new space from the old one with a new grid view. Prolongation/restriction
    is carried out by an external structure that prolongs a discrete function from one space to another discrete
    function in another space. If the user wants to, he can keep the old space and function.
    \item A discrete function should be some storage and a small interface, nothing more.
    \item The magic happens in local operators and local functionals, that do integration and stuff on one entity.
    \item These are either bundled together with a local assembler into a ``systemassembler'' to produce system matrices
    for a linear algebra backend, or these are incorporated into an operator or functional that work on discrete
    functions.
  \end{itemize}
\end{definition}\theoremEndLine

Having this in mind and to elaborate our point, we present two possible discretization schemes for a simple example.


\section{The functionals concept}
\label{section::the_functionals_concept}

In the following we describe the general concept behind \dunefunctionals for {\it linear} problems. In short we can say, that we start with an analytical problem based on analytical operators:
\begin{align*}
\mbox{Find} \enspace u \in X_a \enspace \mbox{with} \qquad A(u)[\phi] = F[\phi] \quad \forall \phi \in X_l.
\end{align*}
This problem is discretized by means of a 'discrete operator' (the numerical method) so that the corresponding discrete problem reads:
\begin{align*}
\mbox{Find} \enspace u_h \in X_{h,a} \enspace \mbox{with} \qquad A_h(u_h)[\phi_h] = F_h[\phi_h] \quad \forall \phi_h \in X_{h,l}.
\end{align*}
The discrete operator (the method) $A_h$ is defined via local operators $A_h^{\omega}$ (localized versions of $A_h$), so that we have:
\begin{align*}
A_h(\phi_h)[\psi_h] = \sum_{\omega =1}^N A_h^{\omega}(\phi_h)[\psi_h].
\end{align*}
These local costituents (local operators) do not only define the chosen numerical method $A_h$, they also define local contributions of the system matrix of the final algebraic problem. 

\subsection{The concept in details}

Now, we describe the concept in details. We use the following notations:
\begin{itemize}
 \item $X$: a Banach-space,
 \item $X_a$: an affine subspace of $X$,
 \item $X_l$: a linear subspace of $X$,
 \item $X^{\prime}$: the dual space of $X$,
 \item $F \in X^{\prime}$: a functional and
 \item $A : X \rightarrow X^{\prime}$: an operator.
\end{itemize}
We are interested in solving: Find $u \in X_a$ with
\begin{align}
\label{original-problem} A(u)[\phi] = F[\phi] \quad \forall \phi \in X_l.
\end{align}
In this sense, we can say that $A$ describes the differential equation (together with a source term $F$).

$\\$
In the next step, we specify an according 'discrete operator' $A_h$, i.e. an operator which describes 'the chosen method' or 'the solution scheme for equation \eqref{original-problem})'. For this purpose we introduce finite-dimensional subspaces of $X$:
\begin{itemize}
 \item $X_h$: a discrete subspace of $X$,
 \item $X_{h,a}$: a discrete subspace of $X$ that approximates $X_a$,
 \item $X_{h,l}$: a discrete subspace of $X_l$,
 \item $F_h \in X_{h}^{\prime}$: a discretized version of $F$ (depending on the numerical method) and
 \item $A_h : X_h \rightarrow X_{h}^{\prime}$: a discretized version of $A$ (describing the numerical method).
\end{itemize}
If possible, we chose $g_h \in X_h$, such that $v_h := u_h - g_h \in X_{h,l}$. Finally, as an approximation of \eqref{original-problem} we solve: Find $v_h \in X_{h,l}$ with
\begin{align}
\label{discretized-problem} A_h(v_h)[\phi_h] = F_h[\phi_h] - A_h(g_h)[\phi_h] \quad \forall \phi_h \in X_{h,l}.
\end{align}
However, from the implementation point of view, we do not want to define $A_h$ directly. Instead of this we only {\it define} localized components $A_h^{\omega}$.
This means that the global operator $A_h$ is constructed from $N$ local operators $A_h^{\omega} : X_h \rightarrow X_{h,l}^{\prime} $ ($1 \le \omega \le N$),  such that:
\begin{align*}
 A_h( \phi_h )[ \psi_h ] = \sum_{\omega=1}^N A_h^{\omega}( \phi_h )[ \psi_h ] \quad \mbox{forall} \enspace \phi_h,\psi_h \in X_{h,l}.
\end{align*}
In this spirit, the local components $A_h^{\omega}$ define the global scheme represented by $A_h$. Furthermore, we will use them to assemble the global system matrix (for the global algebraic problem). Let $S$ denote the system matrix, i.e.:
\begin{align*}
S := \left( \begin{array}{ccc}
  A_h( \phi_{1} )[\phi_{1} ] & ... & A_h^{\omega}( \phi_{1} )[\phi_{n} ] \\
  \vdots & \enspace & \vdots \\
  A_h^{\omega}( \phi_{n} )[\phi_{1} ] & ... & A_h^{\omega}( \phi_{n} )[\phi_{n} ] \\
   \end{array}\right),
\end{align*}
where $\phi_1,...\phi_n$ is a basis of $X_{h,l}$. Now, we assemble local matrices $M_{\omega}$ with relevant local base functions $\phi_{\omega_1},...,\phi_{\omega_N}$:
\begin{align*}
M_{\omega} = \left( \begin{array}{ccc}
  A_h^{\omega}( \phi_{\omega_1} )[\phi_{\omega_1} ] & ... & A_h^{\omega}( \phi_{\omega_1} )[\phi_{\omega_N} ] \\
  \vdots & \enspace & \vdots \\
  A_h^{\omega}( \phi_{\omega_N} )[\phi_{\omega_1} ] & ... & A_h^{\omega}( \phi_{\omega_N} )[\phi_{\omega_N} ] \\
   \end{array}\right).
\end{align*}
Finally, by means of a method \texttt{mapToGlobal}, we sum up these contributions in the following way, to construct the global system matrix $S$:
\begin{align*}
S = \sum_{\omega=1}^N \mu(\omega,M_{\omega}).
\end{align*}
All that remains to be specified is the {\it local-to-global mapping} $\mu$, which is typically already given for a large set of problems.

$\\$
In this sense, the whole concept is a concept of operators and associated localizations of these operators. $A$ contains a describtion of the problem and to define $A_h$, we only need to define the local operators $A_h^{\omega}$ and a method \texttt{mapToGlobal} (describing $\mu$) for the system assembler.

\subsection{Example 1: Standard Finite Elements}

Now we present an easy example for the concept of \dunefunctionals for solving PDE's. We are concerend with a linear elliptic problem with a Dirichlet boundary condition. We want to approach this problem with a standard finite element method with a quadrature formula of order $0$ on each grid element. The notations in this subsection are used in analogy to the notations from the proceding subsection. Beyond this, we assume standard notations. The problem reads as follows:

\begin{example}[Elliptic boundary value problem]\theoremNewline
\label{example::strong_weak_formulation::elliptic_pde}
Let ${\Omega \subset \R^{d=1,2,3}}$ be a bounded connected Lipschitz-domain and let ${a\komma f : \Omega \rightarrow \R}$ and
${g : \boundary\Omega \rightarrow \R}$ be given functions. Find ${u: \Omega \rightarrow \R}$, such that
\begin{align}
\label{equation::strong_weak_formulation::elliptic_pde}
- \divergence \big( a \gradient u \big) &= f &&\text{in } \Omega \komma \\
u &= g &&\text{on } \boundary\Omega \punkt \notag
\end{align}
\end{example}\theoremEndLine

As usual, we will consider the weak formulation of equation \ref{equation::strong_weak_formulation::elliptic_pde}. For this purpose, we define the following operator and functional:
\begin{align*}
A(\phi)[\psi] &:= \int_{\Omega} a(x) \nabla \phi(x) \cdot \nabla \psi(x) \hspace{2pt} dx \quad \mbox{for} \enspace \phi,\psi \in H^1(\Omega) \enspace \mbox{and} \\
F(\phi) &:= \int_{\Omega} f(x) \phi(x) \hspace{2pt} dx \quad \mbox{for} \enspace \phi \in L^2(\Omega).
\end{align*}


\begin{definition}[Weak formulation]\label{definition::strong_weak_formulation::weak_formulation}\theoremNewline
Let $H^1(\Omega)$ and $H^1_0(\Omega)$ be given as usual and let the affine subspace $H^1_g(\Omega)$ be the space of $H^1(\Omega)$-functions with trace $g$ on $\partial \Omega$. Now, the weak problem ist to find $u \in H^1_g(\Omega)$ with
\begin{align}
\label{equation::strong_weak_formulation::analytical_problem1}
A(u)[\phi] = F(\phi) \quad \forall \phi \in H^1_0(\Omega).
\end{align}
\end{definition}

\begin{remark}\theoremNewline
In the setting of the concept we have
\begin{align*}
X=H^1(\Omega), \enspace X_l=H^1_0(\Omega) \enspace \mbox{and} \enspace X_a=H^1_g(\Omega).
\end{align*}
In particular, we get
\begin{align*}
A : X \rightarrow X_l^{\prime} \enspace \mbox{and} \enspace F \in X_l^{\prime}.
\end{align*}
\end{remark}

In the next step we focus on the discretization of the problem, i.e. we introduce finite dimensional subspaces of the relevant spaces and we introduce a 'discrete operator' that describes the numerical method. For this purpose, let $\Tau_h := \Tau_h(\Omega)$ denote an admissible triangulation of $\Omega$. The elements of $\Tau_h$ (the $codim$ 0 entities) are denoted by $T$ and $H \in \R_{>0}$ defines the maximum diameter of all grid elements. Using this notation, we can state the discrete spaces.

\begin{definition}[Finite Element Spaces]\theoremNewline
\label{definition::discretization::finite_element_spaces}
Define the usual (Lagrange) Finite Element Space of globally continuous piecewise polynomials of order $1$ by
\begin{align}
\label{equation::discretization::lagrange_space}
S_{h}^{1} &:=
\big\{ \phi_{h} \in C^{0}(\Omega)
  \big| \phi_{h}|_{T} \in \mathbb{P}^{1}(T) \quad\forall T \in \Tau_{h}
 \big\} \komma
\notag
\intertext{its linear subspace by}
{S_{h,0}^{1}} &:=
\big\{ \phi_{h} \in S_{h}^{1} \big| \phi_{h} = 0 \text{ on } \boundary \Omega \big\}
\notag
\intertext{and its affine subspace by}
{S_{h,g_h}^{1}} &:=
\big\{ \phi_{h} \in S_{h}^{1}
   \big| \phi_{h} - g_{h} \in {S_{h,0}^1}
\big\} \komma \notag
\end{align}
where ${g_{h} \in S_{h}^{1}}$ is a projection of $\hat{g}$ (an arbitrary $H^1$-extension of $g$) onto ${S_{h}^{1}}$.
\end{definition}\theoremEndLine


\begin{definition}[Local and Global Discrete Operators]
\label{definition::discretization::finite_element_spaces}
\theoremNewline
Assume that $a$ and $f$ allow a pointwise evaluation and let $\mathcal{Q}_{T}=\{(q_i,\omega_i)| i \in I_T \}$ denote an quadrature rule on $T$. Then, for $\phi_h,\psi_h \in S_{h}^{1}$, we define the {\it local discrete operators} $A_h^T$ by:
\begin{align*}
A_h^T(\psi_h)[\phi_h] := \sum_{i \in I_T} \omega_i \hspace{2pt} a(q_i) \nabla \phi_h(q_i) \cdot \nabla \psi_h(q_i).
\end{align*}
Here, $q_i$ denotes the quadrature point and $\omega_i$ the weight. Furthermore, we define $F_h^T$ by:
\begin{align*}
F_h^T[\phi_h] := \sum_{i \in I_T} \omega_i \hspace{2pt} f(q_i) \phi_h(q_i).
\end{align*}
The global versions of these operators are therefore given by:
\begin{align*}
A_h(\psi_h)[\phi_h] := \sum_{T \in \Tau_h} A_h^T(\psi_h)[\phi_h] \enspace \mbox{and} \enspace F_h[\phi_h] := \sum_{T \in \Tau_h} F_h^T[\phi_h].
\end{align*}
\end{definition}\theoremEndLine

Finally, we can state the discrete problem (associated with \eqref{equation::strong_weak_formulation::analytical_problem1}):

\begin{definition}[Finite element solution]
\label{definition::discretization::finite_element_solution}
\theoremNewline
Given an approximation ${g_h \in S_h^1}$ of an arbitrary $H^1$-extension of $g$, we are looking for
${{u_h}_0 \in {S_{h,0}^{1}}}$, such that
\begin{align}
A_h({u_h}_0)[\phi_h] = F_h[\phi_h] - A_h(g_h)[\phi_h] &&\text{for all } \phi_h \in {S_{h,0}^{1}} \punkt
\notag
\end{align}
The finite element solution $u_h \in S_{h}^{1} $ for problem \ref{equation::strong_weak_formulation::weak_formulation} is then given by
\begin{align}
u_h := {u_h}_0 + g_h\punkt
\notag
\end{align}
\end{definition}\theoremEndLine


\begin{remark}\theoremNewline
In the setting of the concept we have
\begin{align*}
X_hS_{h}^{1}, \enspace X_{h,l}={S_{h,0}^{1}} \enspace \mbox{and} \enspace X_{h,a}={S_{h,g_h}^{1}}.
\end{align*}
Furthermore, we have
\begin{align*}
A_h^T = A_h^{\omega},
\end{align*}
where $\omega$ denotes the number of the simplex $T$. The total number of simplices is denoted by $N$ and we get
\begin{align*}
A_h(\psi_h)[\phi_h] = \sum_{\omega =1}^N A_h^{\omega}(\psi_h)[\phi_h].
\end{align*}
\end{remark}

Now, we are prepared to assemble the algebraic system of equations that we aim solve in the final step.

\begin{definition}[Algebraic system]
\label{definition::discretization::algebraic_system_fem}
\theoremNewline
Given sets of local basefunctions ${B^T:=\big\{ \varphi_i^T \big| i \in I^T \big\}}$
for all $codim$ 0 entities ${T \in \Tau_h}$ and a suitable local--to--global mapping,
compute the local matrices $M_{T,T}$ and the local vectors $R_T$, $G_T$, defined by
\begin{align}
\left( M_{T,T} \right)_{i,j} &:= A_h^T(\varphi_i^T)[\varphi_j^T] &&\text{for all } i,j \in I^T \enspace \intertext{and}
\notag
\left( R_T \right)_j &:= F_h^T[\varphi_j^T] \quad \left( G_T \right)_j &:= A_h^T(g_h)[\varphi_j^T]  \quad &&\text{for all } j \in I^T
\notag
\end{align}
for all $codim$ 0 entities ${T \in \Tau_h}$. The global system matrix $S$ and the global right hand side vectors $R$ and $G$ are defined
by applying the above mentioned local--to--global mapping $\mu$ elementwise and adding up these contributions:
\begin{align*}
S = \sum_{ T \in \Tau_h } \hspace{-4pt} \mu(T,M_{T,T}), \quad R = \sum_{ T \in \Tau_h } \hspace{-4pt} \mu(T,R_T) \quad \mbox{and} \quad G = \sum_{ T \in \Tau_h } \hspace{-4pt} \mu(T,G_T).
\end{align*}
Now, all we need to solve is
\begin{align}
S \bar{u} = R - G
\end{align}
to obtain the coefficient vector $\bar{u}$ of ${{u_h}_0 \in {S_{h,0}^1}}$. Then we add $g_h$ to obtain ${u_h = {u_h}_0 + g_h \in S_{h}^{1}}$. For details on $\mu$ (\texttt{mapToGlobal}) see \dunefem.
\end{definition}\theoremEndLine


\subsection{Example 2: The Discontinuous Galerkin Method}

In the following subsection, we consider a different discretization scheme. The first discretization (Example 1 - Standard Finite
Element method) uses globally continuous spaces and is thus, in this context, a conforming discretization. On the other hand, the
discretization presented in this subsection (a standard interior penalty Discontinuous Galerkin method) will use discontinuous spaces (thus
is a non-conforming discretization in this context). It will show how we intend to deal with non $codim$ 0 parts
of the discretization.




\section{Implementation of the concept}
\label{section::implementation}

Note that the notations in this subsection might change again.


\subsection{Finite Element Method}
\label{subsection::discretization::finite_element_method}
	

Now that we have a mathematical description of the problem at hand, we would like to highlight some details on how to
solve the problem using \dunefunctionals. Note that we use the ``assembler/global system'' approach here, another
possibility is to define a global operator and a global functional (see \ref{}).

\begin{example}[Finite element solution in \dunefunctionals]
	\label{example::discretization::solution_dune_functionals}
	The following steps have to be undertaken at the moment to solve the above problem using \dunefunctionals.
	In the future, some of these steps should be bundled together to obtain some few simple classes for lazy users.
	Note: we will only highlight the necessary steps for the (local) operator and matrix, the same has to be done for the
	(local) functional and vector.
	\begin{itemize}
		\item \CodeT{DiscreteFunctionSpace::Continuous::Lagrange}: given a \CodeT{FunctionSpace},\\
			provides methods to obtain a local basefunction set and the local--to--global mapping.
		\item \CodeT{DiscreteFunctionSpace::Subspace::Linear::Dirichlet}: given a discrete function space,\\
			provides constraints and all methods from the super space.
		\item \CodeT{DiscreteFunctionSpace::Subspace::Affine::Dirichlet}: given a discrete function space and an analytical
			expression,\\
			carries out a dirichlet--projection,\\
			provides methods to obtain $g_h$ and all methods from the base space.
	  \item \CodeT{EllipticEvaluation}: given two local basefunction sets $B^T$, $B^S$,\\
			returns a local matrix ${\big(a \gradient \varphi_i^T \gradient \varphi_j^S\big)_{i,j}}$ for all ${\varphi_i^T \in B^T}$,
			${\varphi_i^T \in B^T}$. It is required for specifying the local discrete operators.
		\item \CodeT{DiscreteOperator::Local::Codim0::Integral}: given a local evaluation and two local basefunction sets,\\
			carries out a $codim$ 0 integration by applying a quadrature rule and evaluating the local evaluation at each quadrature point,\\
			returns a local matrix ${A^{T,T}}$ (the 'bundle' local discrete operators defines the method, i.e. the global discrete operator).
		\item \CodeT{Assembler::Local::Codim0::Matrix}: given a local operator, two discrete function spaces, an entity and
			the global matrix $A$,\\
			gets the corresponding local basefunction sets, calls the local operator and adds the resulting local matrix to
			$A$.
		\item \CodeT{Container::Matrix::Defaults< ... >::BCRSMatrix}: provides an auto--pointer to a suitable storage object.
		\item \CodeT{Assembler::System::Affine}: given two discrete function spaces, two local assemblers and storage for
			$A$, $F$ and $G$,\\
			walks the grid and calls the local assemblers on each entity (note: the assembler automatically creates a local
			vector assembler for the affine contribution),
			walks the grid again to apply local constraints\\
		\item Some solver...
	\end{itemize}
	At the moment the user only has to implement an \CodeT{EllipticEvaluation} and a \CodeT{ProductEvaluation}, the rest is
	provided by \dunefunctionals.  
\end{example}\theoremEndLine

We would like to point out some final remarks for this example.

\begin{remark}\theoremNewline
  \label{remarks::discretization::final_remarks_fem}
  \begin{itemize}
    \item The local evaluation, the local operator and the local assembler are all instanciated without a discrete
			function space. This objects are lightweight and can be copied without restriction.
		\item The discrete function spaces are given only to the system assembler.
		\item Another (not yet implemented) possibility is:
			\begin{itemize}
				\item Define global operator and global functionals, given their local counterparts and discrete function
					spaces.
				\item These can be either applied on--the--fly or assemble themselves or register themselves at a
					``grid--walker'', which would call an \CodeT{applyLocal} method to allow them to assemble themselves.
				\item These would more or less comply to the existing \dunefem operator and could be given to a solver,
					ode--integrator or nonlinear solver.
			\end{itemize}
	\end{itemize}
\end{remark}\theoremEndLine
  
%   \bibliographystyle{plain}
%   \bibliography{dune-fem-functionals}

\end{document}




