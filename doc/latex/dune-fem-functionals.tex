% ==================================================================================================================== %
% dune-fem-functionals.tex
% by: Felix Albrecht (felix.albrecht@uni-muenster.de)
%     Patrick Henning (patrick.henning@uni-muenster.de)
% ==================================================================================================================== %
\documentclass[a4paper,11pt]{article}

% required packages and definitions
\usepackage[utf8]{inputenc}
% \usepackage[body={148mm,240mm,nohead}]{geometry}

\usepackage{multicol}
\usepackage{xspace}
\usepackage{relsize}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\numberwithin{equation}{section}
\newtheorem{definition}{Definition}[section]
\newtheorem{class}[definition]{Class}
\newtheorem{remark}[definition]{Remark}
\newtheorem{example}[definition]{Example}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{problem}[definition]{Problem}
\newcommand{\theoremNewline}{\hspace{1mm}\\}
\newcommand{\theoremEndLine}{\hspace{1mm}}
\newcommand{\theoremItemizeNewline}{\hspace{1mm}\vspace{-3mm}}

\usepackage{hyperref}
\usepackage{url}

\usepackage{listings}
\lstset{language=C++,basicstyle=\ttfamily}
\newcommand{\Code}[1]{\texttt{#1}}
\newcommand{\code}[1]{\lstinline!#1!}
\newcommand{\CodeT}[1]{\textnormal{\texttt{#1}}}
\newcommand{\codeT}[1]{\textnormal{\lstinline!#1!}}

\usepackage{tikz}
\usepgflibrary{arrows}

\newcommand{\dune}{\textsc{Dune}\xspace}
\newcommand{\dunecommon}{\textsc{Dune-Common}\xspace}
\newcommand{\dunegrid}{\textsc{Dune-Grid}\xspace}
\newcommand{\duneistl}{\textsc{Dune-Istl}\xspace}
\newcommand{\dunelocalfunctions}{\textsc{Dune-Localfunctions}\xspace}

\newcommand{\dunefem}{\textsc{Dune-Fem}\xspace}
\newcommand{\dunefemfunctionals}{\textsc{Dune-Fem-Functionals}\xspace}
\newcommand{\dunepdelab}{\textsc{Dune-PDELab}\xspace}
\newcommand{\dumux}{\textsc{DuMu}$^\textrm{x}$\xspace}

\newcommand{\alugrid}{\textsc{ALUGrid}\xspace}
\newcommand{\alberta}{\textsc{ALBERTA}\xspace}

\newcommand{\albertagrid}{{\tt AlbertaGrid}\xspace}
\newcommand{\alusimplexgrid}{{\tt ALUSimplexGrid}\xspace}
\newcommand{\alucubegrid}{{\tt ALUCubeGrid}\xspace}
\newcommand{\aluconformgrid}{{\tt ALUConformGrid}\xspace}
\newcommand{\uggrid}{{\tt UGGrid}\xspace}
\newcommand{\onedgrid}{{\tt OneDGrid}\xspace}
\newcommand{\sgrid}{{\tt SGrid}\xspace}
\newcommand{\yaspgrid}{{\tt YaspGrid}\xspace}

\newcommand{\hnS}{\hspace{-1.25pt}}
\newcommand{\divergence}{\nabla\hnS\hnS\hnS\cdot}
\newcommand{\gradient}{\nabla\hnS\hnS}
\newcommand{\boundary}{\partial \hnS}
\newcommand{\dx}{\;d\hnS x}
\newcommand{\komma}{\text{,}}
\newcommand{\punkt}{\text{.}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}

\title{Draft on \dunefemfunctionals}
\author{Felix Albrecht (\Code{felix.albrecht@uni-muenster.de}) and\\
  Patrick Henning (\Code{patrick.henning@uni-muenster.de})
}
\date{\today}

\begin{document}

  \maketitle

  \begin{abstract}
    This document is a draft about a new concept of \dunefem based on functionals. \dunefem is part of the
    Distributed and Unified Numerics Environment (\dune) and is available from
    \url{http://dune.mathematik.uni-freiburg.de/}.
  \end{abstract}

  \hrule

  \begin{multicols}{2}
    \small\tableofcontents
  \end{multicols}

  \hrule

  \section{Introduction}

    The overall goal of \dunefem and \dunefemfunctionals is the efficient numerical solution of PDE's. Assuming standard
    notation, the following elliptic PDE may serve as a sample problem.

    \begin{example}[Elliptic PDE in one dimension]\theoremNewline
      \label{example::introduction::elliptic_pde}
      Let ${\Omega \subset \R}$ be a domain and ${a\komma f : \Omega \rightarrow \R}$ and
      ${g : \boundary\Omega \rightarrow \R}$ be given functions. Find ${u: \Omega \rightarrow \R}$, such that
      \begin{align}
        \label{equation::introduction::elliptic_pde}
        - \divergence
          \big(
            a \gradient u
          \big)
          &= f &&\text{in } \Omega \komma
        \\
        u &= g &&\text{on } \boundary\Omega \punkt
        \notag
      \end{align}
    \end{example}\theoremEndLine

    \begin{definition}{Weak formulation}\theoremNewline
      \label{definition::introduction::weak_formulation}
      Let $H^1$ and $H^1_0$ be given as usual and let $H^1_g$ for ${g\in H^1}$ be defined as
      \begin{align}
        H^1_g :=
          \big\{
            v \in H^1
          \big|
            v = w + g \text{ for a } w \in H^1_0
          \big\}\punkt
        \notag
      \end{align}
      The weak formulation of problem \eqref{equation::introduction::elliptic_pde} then reads as follows. Find
      ${u \in H^1_g}$, such that
      \begin{align}
        \label{equation::introduction::weak_formulation}
        \int\limits_{\Omega}
          a \gradient u \gradient v
        \dx
        =
        \int\limits_{\Omega}
          f v
        \dx
        &&\text{for all } v \in H^1_0 \punkt
      \end{align}
    \end{definition}

    The weak formulation \eqref{equation::introduction::weak_formulation} gives rise to the introduction of
    functionals and operators. A rigorous mathematical definition of these can be found in the next section.
    The following is only intended to give the basic idea.

    \begin{definition}[Operators and functionals]\theoremNewline
      \label{definition::introduction::operators_functionals}
      The function $f$ from he original problem \ref{equation::introduction::elliptic_pde} induces a functional
      \begin{align}
        F: H^1_0 &\rightarrow \R
          \notag\\
        v &\mapsto F[v] :=
          \int\limits_{\Omega}
            f v
          \dx\punkt
          \notag
        \intertext{Accordingly the function $a$ from the original problem \ref{equation::introduction::elliptic_pde}
          induces an operator}
        A: H^1_g &\rightarrow H^{-1}
          \notag\\
        u &\mapsto A(u) \komma
          \notag
        \intertext{where $A(u)$ itself is a functional, defined by}
        A(u): H^1_0 &\rightarrow \R
          \notag\\
        v &\mapsto A(u)[v] :=
          \int\limits_{\Omega}
            a \gradient u \gradient v
          \dx\punkt
          \notag
      \end{align}
    \end{definition}

    With these definitions at hand the weak formulation \eqref{equation::introduction::weak_formulation} can be
    rewritten in the following way.

    \begin{remark}[Variational formulation using functionals and operator]\theoremNewline
      \label{remakr::introduction::variational_formulation_functionals_operators}
      Let $A$ and $F$ be as in definition \ref{definition::introduction::operators_functionals}. The weak formulation
      \eqref{equation::introduction::weak_formulation} can be rewritten as follos.
      Find ${u \in H^1_g}$, such that
      \begin{align}
        \label{equation::introduction::variational_formulation_functionals_operators}
        A(u)[v] = F[v] &&\text{for all } v\in H^1_0 \punkt
      \end{align}
    \end{remark}

    Our postulate is, that a wide range of interesting problems can be written in this form. For detailed examples of
    linear and nonlinear problems see section ?.

  \section{Analytical concept}

    We start with an overview on the mathematical concept which is carried over to a corresponding programming
    concept. The following notations and definitions are required for the subsequent sections.

    \begin{definition}[Function and Functionspace]\theoremNewline
      \label{definition::analytical_concept::function_functionspace}
      Let ${n,d \in \N^{\geq 1}}$ be integers and ${\Omega \subseteq \mathbb{R}^n}$ a subset. A mapping
      ${v : \Omega \rightarrow \R^d}$ is called a \textnormal{function}, the set
      \begin{align}
        V :=
          \big\{
            v : \Omega \rightarrow \R^d
          \big\}
          \notag
      \end{align}
      is called a \textnormal{functionspace}. If $V$ is an $\R$--vector space, $V$ is called a \textnormal{linear functionspace}.
    \end{definition}\theoremEndLine

    \begin{definition}[Functional]\theoremNewline
      \label{definition::analytical_concept::functional}
      Let $V$ be a function space. A map
      \begin{align}
        F: V &\rightarrow \R\komma
          \notag\\
        v &\mapsto F[v]
      \end{align}
      is called a \textnormal{Functional}. If
      \begin{align}
        F[\alpha v_1 + \beta v_2] = \alpha F[v_1] + \beta F[v_2]
          \notag
      \end{align}
      holds for all ${\alpha,\beta \in \R}$ and all ${v_1,v_2\in V}$, $F$ is called a \textnormal{Linear Functional}.
      The vector space
      \begin{align}
        V' := \big\{ F : V \rightarrow \R \big| F \text{ is a linear functional } \big\}
      \end{align}
      is called the dual space of $V$.
    \end{definition}\theoremEndLine

    \begin{definition}[Constraint]\theoremNewline
      \label{definition::analytical_concept::constraint}
      Let $V$ be a linear function space, $M \in \mathbb{N}_{>0}$ and $\{ F_1, ..., F_M \}$ a set of linear
      functionals on $V$. We define the corresponding vector of linear functionals $C$ by
      \begin{align}
        C: \{1,...,M\} \times V &\rightarrow \R \enspace \mbox{with} \enspace (i,v) \mapsto C[i][v] := F_i[v].
      \end{align}
      The condition:
        \begin{align}
        C[i][v] = 0 \enspace \forall 1 \le i \le M
        \end{align}
      is called a \textnormal{Constraint} for $v$.
    \end{definition}

    In particular each linear functional implies a constraint.

    \begin{definition}[Linear Subspace]\theoremNewline
      \label{definition::analytical_concept::linear_subspace}
      Let $V$ be a linear function space and $C[\cdot][\cdot]=0$ a constraint on $V$. Then we call
      \begin{align}
        V_C := \{ v \in V| \hspace{4pt} C[i][v] = 0 \hspace{4pt}\forall i\in\{1,...,M\}\}
      \end{align}
      a \textnormal{linear subspace} of $V$ with respect to $C$.
    \end{definition}

    $V_C$ is a vector space itself, since the constraint functionals $C[i]$ are linear. Typically, $V_C$ becomes the
    space of test functions in our later problem.

    \begin{definition}[Affine space]\theoremNewline
      \label{definition::analytical_concept::affine_space}
      Let $V$ be a function space, $V_C$ a linear subspace and $g \in V$. Then we call
      \begin{align}
        V_{g} := \{ v+g| \hspace{4pt} v \in V_C \} \subset V
      \end{align}
      an \textnormal{affine space} with respect to $g$ and $V_C$.
    \end{definition}\theoremEndLine

    In general, $V_g$ is only a subset of $V$ and not a subspace. It will be the space of solutions in our later
    problem.

    \begin{definition}[Operator]\theoremNewline
      \label{definition::analytical_concept::operator}
      Let $V$ be a linear function space, ${V_C \subset V}$ a linear subspace, $V_C'$ its dual and ${V_g \subset V}$
      an affine space. Then we call
      \begin{align}
        G : V_g \rightarrow V^{\prime}_C
      \end{align}
      an \textnormal{operator} on $V_g$. If
      \begin{align}
        G(\alpha v + \beta w) = \alpha G(v) + \beta G(w)
          \notag
      \end{align}
      holds for all ${\alpha\komma \beta \in \R}$ and for all ${v\komma w \in V_g}$ the operator $G$ is called
      \textnormal{linear}.
    \end{definition}

    In the subsequent sections, we are dealing with the following problem.

    \begin{problem}{Sample problem}\theoremNewline
      \label{problem::analytical_concept::sample_problem}
      Let $V$ be a linear space, ${V_C \subset V}$ a linear subspace, ${F \in V_C'}$ a functional and
      ${V_g \subset V}$ an affine space. Find ${u \in V_g}$, such that
      \begin{align*}
        G(u)[v] = F[v] &&\text{for all } v \in V_C.
      \end{align*}
    \end{problem}

    In general, the functional $F$ on the right hand side of our problem is linear. The (differential) operator $G$
    can be either linear or nonlinear.

  \section{Examples}

    \subsection{Elliptic PDE}

      Let $\Omega \subset \mathbb{R}^d$ denote a polygonal bounded domain, $\mathcal{T}_H = \{ T_1, ..., T_N \}$ a
      corresponding regular triangulation, $\mathcal{N}_H = \{ x_1, ...., x_{\tilde{N}}\}$ the set of nodes and
      $\{ \Phi_1, ...., \Phi_{\tilde{N}}\}$ the associated Lagrange basis of order $1$. The (discrete) linear space of
      solutions is given by
      \begin{align*}
        V :=
          \Big\{
            v_H \in C^0(\Omega)
          \Big|
            (v_H)_{|T}\in \mathbb{P}^1(T) \quad\forall T \in \mathcal{T}_H
          \Big\}
      \end{align*}
      and the linear subspace of testfunctions by $V_0 := V \cap H^1_0(\Omega)$. Now, let us consider the
      following discrete problem.

      \begin{problem}\theoremNewline
      For $g \in V$ find $u \in V$ with $u=g$ on $\partial \Omega$ and
      \begin{align*}
      \int\limits_{\Omega} \nabla u \cdot \nabla v \dx = \int\limits_{\Omega} f v \dx &&\text{for all }v \in V_0.
      \end{align*}
      (Note: $V_0$ can not be replaced by $V$).
      \end{problem}

      Putting this into the general framework above, we define the (linear) functional
      ${F: V_0 \rightarrow \R}$ by
      \begin{align*}
        F[v] := \int\limits_{\Omega} f v &&\text{for } v \in \mathring{V}.
      \end{align*}
      $V_0$ is a constraint subspace with the constraint $C[i][v] := v(x_i^b) = 0$ for any boundary node
      $x_i^b$ (i.e. $\mathcal{N}_H \cap \partial \Omega = \{ x_1^b, ...., x_{\bar{N}}^b\}$). We can therefore identify
      \begin{align*}
        V_0 = \{ v \in V| \hspace{3pt} C[i][v] = 0 \enspace \forall 1\le i\le \bar{N} \} =: V_C.
      \end{align*}
      The affine space $V_{g_H}$is given by
      \begin{align*}
        V_{g_H} :=
          \Big\{
            v + g_H
          \Big|
            v \in V \enspace \mbox{and} \enspace g_H := \sum_{i=1}^{\tilde{N}} g(x_i) \Phi_i
          \Big\}
      \end{align*}
      and the (differential) operator $G : V_{g_H} \rightarrow V_C^{\prime}$ by
      \begin{align*}
      G(u)[v] := \int_{\Omega} \nabla u \cdot \nabla v \dx.
      \end{align*}
      With these notations the original problem reads:
      \begin{align*}
      \text{Find} \enspace u \in V_{g_H} \enspace \mbox{with} \enspace G(u) = F \enspace \mbox{on} \enspace V_C.
      \end{align*}

  \section{Programming concept}

    In this section we describe the general programming concept. For a detailed description of these classes, see
    section ? and the doxygen documentation. These classes are realized in a namespace \Code{Functionals} in order to
    avoid conflicts with other existing \dunefem-classes. We do not distinguish between interfaces and realizations
    here, this is only intended as a conceptual overview.

    \subsection{Functionals}

      \begin{remark}[Class tree]\theoremItemizeNewline
        \begin{itemize}
          \item[] \CodeT{Functional}
          \item[] \begin{itemize}
                    \item[$\rightarrow$] \CodeT{CombinedFunctional}
                    \item[$\rightarrow$] \CodeT{LinearFunctional}
                    \item[] \begin{itemize}
                            \item[$\rightarrow$] \CodeT{CombinedLinearFunctional}
                            \item[$\rightarrow$] \CodeT{CodimCFunctional}
                            \item[$\rightarrow$] \CodeT{IntegralFunctional}
                          \end{itemize}
                  \end{itemize}
        \end{itemize}
      \end{remark}

      \begin{class}[\CodeT{Functional}]\theoremNewline
        This class represents a functional $F$ (see definition \ref{definition::analytical_concept::functional}). It
        provides the base class for linear and nonlinear functionals.\\\\
        \begin{tabular}{l}
          \textbf{Class definition:}\\
          \hline
          \hline
          \codeT{class Functional< FunctionSpaceType >}
        \end{tabular}\\\\\\
        \noindent
        \begin{tabular}{l}
          \textbf{Methods:}\\
          \hline
          \hline
          \codeT{RangeFieldType ret = operator( FunctionType function )}\\
          \begin{tabular}{l|l}
            description:
              & This method represents the functional, applied to a function.\\
            \hline
            in:
              & \begin{tabular}{ll}
                  \codeT{FunctionType function}
                  & $v$
                \end{tabular}\\
            \hline
            out:
              & \begin{tabular}{ll}
                  \codeT{RangeFieldType ret}
                  & ${F[v]}$
                \end{tabular}
          \end{tabular}
        \end{tabular}
      \end{class}\theoremEndLine

      \begin{class}[\CodeT{CombinedFunctional}]\theoremNewline
        Given two functionals ${F \komma G \in V'}$, this class represents the functional
        \begin{align}
          F+G: V &\rightarrow  \R
            \notag\\
          v &\mapsto F[v] + G[v]\punkt
            \notag
        \end{align}
        This class is derived from \codeT{Functional}.\\\\
        \begin{tabular}{l}
          \textbf{Class definition:}\\
          \hline
          \hline
          \codeT{class CombinedFunctional< FirstFunctionalType, SecondFunctionalType >}\\
          \codeT{: Functional}
        \end{tabular}\\\\\\
        \noindent
        \begin{tabular}{l}
          \textbf{Methods:}\\
          \hline
          \hline
          \codeT{RangeFieldType ret = operator( FunctionType function )}\\
          \begin{tabular}{l|l}
            description:
              & This method redefines \codeT{Functional::operator()}.\\
            \hline
            in:
              & \begin{tabular}{ll}
                  \codeT{FunctionType function}
                  & $v$
                \end{tabular}\\
            \hline
            out:
              & \begin{tabular}{ll}
                  \codeT{RangeFieldType ret}
                  & ${F[v] + G[v]}$
                \end{tabular}
          \end{tabular}
        \end{tabular}
      \end{class}\theoremEndLine


\subsection{Required classes}

First of all we give an overview on the various classes that are required in our concept. In particuler we comment on the functionality of each class.\\
\\
{\tt typedef Constraint < FunctionalType > ConstraintType;}
\begin{itemize}
\item[$\circ$] various realizations of constraints $C$ are possible (boundary conditions, periodicity, zero-average, ...); they are derived from the general {\tt Constraint} class
\item[$\circ$] mapping an element $v\in V$ on an element $v_C \in V_C$ is not unique, therefore 'applying a constraint' to a general function $v$ means that we project $v$ on $V_C$ with respect to certain scalar product; in the discrete setting these projections are typically straight forward
\item[$\circ$] required methods:
\item[$\cdot$] method: {\tt apply( numberOfConstraint, function )} $\leftrightarrow$ find $v_C \in V_C$ which is 'close' to $v$ and which fulfills $C[i][v_C]=0$, $i$ is the index of the functional (in our functional vector), $v$ is an analytical function
\item[$\cdot$] method: {\tt apply( numberOfConstraint, discreteFunction )} $\leftrightarrow$ find $v_C \in V_C$ which is 'close' to $v_H$ and which fulfills $C[i][v_C]=0$, $i$ is the index of the functional (in our functional vector), $v_H$ is a discrete function; typically we simply change the value of $v_H$ in a certain number of nodes
\item[$\cdot$] method: {\tt applyLocal( numberOfConstraint, localBasefunctionSet, \\ localBasefunctionSet )} $\rightarrow$ again, an abstract method depending on the specific type of the constraint; it returns local contributions for a specific grid element; it is required for assembling the system matrix in our system of equations; details are given later
\item[$\cdot$] method: {\tt applyLocal( localBasefunctionSet, localBasefunctionSet )} $\rightarrow$ use {\tt applyLocal( numberOfConstraint, localBasefunctionSet, \\ localBasefunctionSet )} for all {\tt numberOfConstraint}
\item[$\circ$] other methods depending on the specific type of a constraint (e.g. DirichletConstraint)?
\item[$\circ$] constraints are used to construct a 'constraint subspace' - for the user, nothing else has to be done with the constraints
\end{itemize}
{\tt typedef LinearSubspace < DiscreteFunctionSpace, ConstraintType >

\hspace{1pt}LinearSubspaceType;}
\begin{itemize}
\item[$\circ$] derived from {\tt DiscreteFunctionSpace}
\item[$\circ$] all the information about the constraint is in our subspace
\item[$\circ$] we can extract the constraint that it was constructed from
\item[$\circ$] formally the subspace is of the same size as {\tt DiscreteFunctionSpace}
\item[$\circ$] in particular an object of {\tt LinearSubspace} becomes the space of test functions in our later problem
\end{itemize}
{\tt typedef AffineSubspace < LinearSubspace > AffineSubspaceType;}
\begin{itemize}
\item[$\circ$] the space of the solution
\item[$\circ$] initialized with a fixed discrete function $v_H$: 'AffineSubspace = $v_H$ + LinearSubspace'
\item[$\circ$] {\tt AffineSubspace}-class derived from {\tt DiscreteFunctionSpace}
\end{itemize}
{\tt typedef Operator< LinearSubspaceType, AffineSubspaceType,

\hspace{1pt}MatrixObjectTraits > DifferentialOperatorType;}
\begin{itemize}
\item[$\circ$] can be derived from the dune-fem Operator-class, later it should be implemented independently
\item[$\circ$] Operator : AffineSubspace $\rightarrow$ (LinearSubspace$)^{\prime}$
\item[$\circ$] if required: automatically assembles the correct system matrix (which is a quadratic sparse row matrix) with respect to the subspaces (i.e. with respect to the constraints)
\item[$\circ$] simplified we can say: the {\it linear subspace} tells us which lines we must substitute in our later system of equations and the {\it affine subspace} tells us by what we must substitute these lines.
\item[$\circ$] usage of a {\tt DifferentialOperatorType}-object identical to the old usage of an {\tt Operator}-object
\item[$\circ$] get system matrix with {\tt operator.systemMatrix();}
\end{itemize}

Algebraic classes (assembling of system matrix and right hand side):\\
\\
To assemble the right hand side in our system of equations:\\
{\tt typedef FunctionalAssembler < FunctionalType, AffineSubspace >

FunctionalAssemblerType;}\\
\\
To assemble the correct system matrix (with respect to the subspaces):\\
{\tt typedef OperatorAssembler < OperatorType > OperatorAssemblerType;}
\begin{itemize}
\item incorporates something like:\\
{\tt assembleSystemMatrix(); constraints.apply( systemMatrix() );}\\
\end{itemize}
Both classes might be incorporated in a general {\tt FunctionalSolverInterface}, so that the user does not need to care about the system assemblers.


\subsection{Draft}


Essential classes: \\
\\
{\footnotesize\tt
using namespace Functionals;\\
\\
typedef Functional< DiscreteFunctionSpace > FunctionalType; \\
typedef Constraint < FunctionalType > ConstraintType; \\
typedef LinearSubspace < DiscreteFunctionSpace, ConstraintType > LinearSubspaceType; \\
typedef AffineSubspace < LinearSubspace > AffineSubspaceType; \\
\\
{\sl// sparse row matrix of size $N \times N$}\\
typedef Dune::SparseRowMatrixTraits < DiscreteFunctionSpace, DiscreteFunctionSpace >  MatrixObjectTraits; \\
typedef Operator< LinearSubspaceType, AffineSubspaceType,

MatrixObjectTraits > DiffOperatorType; \\
\\
{\sl// algebraic system assemblers:}\\
typedef OperatorAssembler < OperatorType > OperatorAssemblerType; \\
typedef FunctionalAssembler < FunctionalType, AffineSubspace > FunctionalAssemblerType; \\
\\
{\sl// CG scheme}\\
typedef CGInverseOp< DiscreteFunctionType, OperatorAssembler > InverseOperatorType; \\
}
\\
Main code: \\
\\
{\tt\footnotesize
DiscreteFunctionType rhs( "right hand side", discreteFunctionSpace ); \\
\\
{\sl// use a right hand side assembler class to apply 'functional+constraints' to right hand side vector}\\
FunctionalAssemblerType rhsAssembler ( functional, affineSubspace ); \\
rhsAssembler.assemble( rhs ); \\
\\
{\sl// behaves like the old Operator-class of \dunefem:}\\
OperatorAssemblerType systemMatrixAssembler ( differentialOperator );
\\
{\sl// 'differentialOperator' contains correct 'systemMatrix()':}\\
InverseOperatorType cg( systemMatrixAssembler, 1e-6, 1e-8 );\\
cg( rhs, solution );\\}
\\
We might think about hiding this main code behind a 'FunctionalSolverInterface', so that the user can simply call:

{\tt\footnotesize cg( differentialOperator, functional, affineSubspace, solution );}\\
(i.e. {\tt FunctionalSolverInterface< Operator, Functional, AffineSubspace>} )

$\\$
Comparison with 'old' main code (for laplace operator and zero boundary condition):\\
\\
{\tt\footnotesize DiscreteFunctionType rhs( "rhs", discreteFunctionSpace );\\
AssembledFunctional< FunctionalType > rhsFunctional ( disceretFunctionSpace, functional );\\
rhsFunctional.assemble( rhs );\\
\\
typedef LaplaceOperator< DiscreteFunctionType, MatrixObjectTraits > LaplaceOperatorType;\\
{\sl// apply constraints}\\
bool hasDirBoundary = constraints.apply( laplaceOperator.systemMatrix(), rhs, solution );\\
\\
InverseOperatorType cg( laplaceOperator, 1e-6, 1e-8 );\\
cg( rhs, solution );\\}
\\
The essential difference is that the (differential)operator already knows the correct system matrix (due to the subspaces, that know the constraints). Therefore the user does not need some kind of 'constraints.apply' method (this happens internally in the two system assemblers).

\section{Realization of Functionals}

    \begin{class}[\Code{Functional< Space >}]\theoremNewline
      Represents a functional $f$. This class comes without any functionality at the moment, until someone comes
      up with a reasonable example of nonlinear functionals.\\\\
      \begin{tabular}{|l|l|}
        \hline
        \CodeT{number = operator( function )}
          & Given $u$, returns $f[u]$.\\
        \hline
      \end{tabular}
    \end{class}\theoremEndLine

  \subsection{Linear Functionals}

    \begin{definition}[Linear functional]\theoremNewline
      Let $V$ be a vector space, $\K$ its underlying scalar field and $f$ a functional. If, for all
      ${u \komma v \in V}$ and for all ${\lambda \komma \mu \in \K}$,
      \begin{align}
        f[ \lambda u ] + f[ \mu v ] = \lambda f[u] + \mu f[v]
      \end{align}
      holds, $f$ is called a \textnormal{linear functional}.
    \end{definition}\theoremEndLine

    \begin{definition}[Dual Space]\theoremNewline
      Let $V$ be a vector space and $\K$ its underlying scalar field. The space
      \begin{align}
        V^{*} :=
            \big\{
              f: V \rightarrow \K
            \big|
              f \text{ linear functional}
            \big\}
          \notag
      \end{align}
      is called the \textnormal{dual space} of $V$ and is a vector space itself.
    \end{definition}\theoremEndLine

    \begin{lemma}[Localization property of linear functionals]\theoremNewline
      Let $V_G$ be a discrete function space (\cite[Def. 18]{DKNO10}) and ${f \in V_G^*}$ a linear functional. Let
      further be
      \begin{align}
        u = \sum\limits_{E \in G}
            {
              \sum\limits_{i \in I_E}
              {
                u_i^E \varphi_i^E
              }
            }
      \end{align}
      the representation for a ${u \in V_G}$ in terms of its local DoFs $u_i^E$ and the local
      base functions $\varphi_i^E$ (\cite[Def. 20]{DKNO10}). Then it holds that
      \begin{align}
        f[u] &= \sum\limits_{E \in G}
            {
              \sum\limits_{i \in I_E}
              {
                u_i^E f \Big[ \varphi_i^E \Big]
              }
            }\komma
        \intertext{which can also be written as}
        f[u] &= \sum\limits_{E \in G}
            {
              u^E \cdot f[B_E]^E
            }\komma
      \end{align}
      where $u^E := ( u_i^E )_{i \in I_E}$ is the local DoF vector of $u$ on $E$ and ${f[B_E]^E}$ is defined as the vector
      \begin{align}
        f[B_E]^E := \Bigg( f \Big[ \varphi_i^E \Big] \Bigg)_{i \in I_E}
      \end{align}
      for a local basfunction set $B_E$.
    \end{lemma}\theoremEndLine

    \begin{class}[\Code{LinearFunctional< Space, DiscreteFunctionSpace >:Functional}]\theoremNewline
      Represents a linear functional $f$.\\\\
      \begin{tabular}{|l|l|}
        \hline
        \CodeT{number}
          & Redefines \CodeT{Functional::operator()}.\\
        \CodeT{ = operator( function )}
          & Given $u$, computes ${\sum\limits_{E \in G} u^E \cdot f[B_E]^E}$\\
          & by doing a gridwalk and calling\\
          & \CodeT{applyLocal()} on each entity.\\
        \hline
        \CodeT{vector}
          & Implements $f[B_E]^E$.\\
        \CodeT{ = applyLocal( localBasefunctionSet )}
          & Given $B_E$, computes ${( f [ \varphi_i^E ] )_{i \in I_E}}$\\
        \hline
      \end{tabular}
    \end{class}\theoremEndLine

  \subsection{Integral Functionals}

    \begin{definition}[Integral functional]\theoremNewline
      Let $V$ be a vector space, ${u \in V}$ and ${f \in V^*}$. If $f[u]$ can
      be decomposed as
      \begin{align}
        f[u] = \sum\limits_{c = 0}^{dim}
            {
              f^c [u]
            }\komma
      \end{align}
      where ${f^c \in V^*}$ are \textnormal{codim c integral functionals}, which can be written as
      \begin{align}
        f^c [u] = \int\limits_{\omega^c} \tilde{f}^c[u]
      \end{align}
      for a set $\omega^c$ of codimension $c$ and a functional ${\tilde{f}^c \in V^*}$, then $f$ is called an
      \textnormal{integral functional}.
    \end{definition}\theoremEndLine

    \begin{lemma}[Localization property of integral functionals]\theoremNewline
      Let $V_G$ be a discrete function space and ${f \in V_G^*}$ an integral functional. Then it holds that
      \begin{align}
        f[u] &= \sum\limits_{E \in G^0}
            {
              \sum\limits_{i \in I_E}
                {
                  u_i^E \sum\limits_{c=0}^{dim}
                    {
                      f^c[ \varphi_i^E ]
                    }
                }
            }
          \notag\\
        &= \sum\limits_{E \in G^0}
            {
              u^E \cdot
                \Bigg(
                  \sum\limits_{c=0}^{dim}
                    {
                      \int\limits_{G_E^0}
                        {
                          \tilde{f}^c[B_E]^E
                        }
                    }
                \Bigg)
            }\komma
        \intertext{where $(\dots)$ is to be understood as the vector}
        \Bigg(
            \sum\limits_{c=0}^{dim}
              {
                \int\limits_{G_E^0}
                  {
                    \tilde{f}^c[B_E]^E
                  }
              }
          \Bigg) &:=
            \Bigg(
              \sum\limits_{c=0}^{dim}
                {
                  \int\limits_{G_E^c}
                    {
                      \tilde{f}^c[\varphi_i^E]
                    }
                }
            \Bigg)_{i \in I_E}
          \komma
      \end{align}
      where $G_E^c$ is ``the set of all codim $c$ entities, that lie inside E''.
    \end{lemma}\theoremEndLine

    \begin{class}[\Code{LocalOperationProvider}]\theoremNewline
      Represents the operation ${\tilde{f}^c[\varphi_i^E]}$, e.g. ${\tilde{f}^c[\varphi_i^E] = f(x)\varphi_i^E(x)}$.
      This class has to be provided by the user in order to define a
      \CodeT{CodimIntegralFunctional} (see below).\\\\
      \begin{tabular}{|l|l|}
        \hline
        \CodeT{number}
          & Given a point $x$ in local coordinates, returns $\tilde{f}^c[\varphi_i^E](x)$,\\
        \CodeT{ = apply( function,}
          & where $\varphi_i^E$ is given as \CodeT{function} and some function\\
        \CodeT{ localPoint,}
          & associated with the functional can be given as\\
        \CodeT{ functionalFunction = 1 )}
          & \CodeT{functionalFunction}\\
        \hline
      \end{tabular}
    \end{class}\theoremEndLine

    \begin{class}[\Code{CodimIntegralFunctional< LocalOperationProvider >:LinearFunctional}]
      Represents a codim c functional ${f^c[u]}$. A \CodeT{CodimIntegralFunctional} provides an additional method
      \CodeT{prepareLocalIntegration()} to facilitate the integration in\\
      \CodeT{IntegralFunctional::applyLocal()} (see below). There should be derived classes for each codimension, which,
      together with a suitable \CodeT{LocalOperationProvider}, can be given to an \CodeT{IntegralFunctional} to provide
      something like an \CodeT{L2Functional} for the user.\\\\
      \begin{tabular}{|l|l|}
        \hline
        \CodeT{number}
          & Inherited from \CodeT{LinearFunctional}.\\
        \CodeT{ = operator( function )}
          & \\
        \hline
        \CodeT{vector}
          & Redefines \CodeT{LinearFunctional::applyLocal()}.\\
        \CodeT{ = applyLocal( localBasefunctionSet )}
          & Given ${B_E}$, computes ${(f^c[\varphi_i^E])_{i\in I_E}}$ by\\
          & doing a codim c integration by quadrature\\
          & and calling \CodeT{prepareLocalIntegration()}\\
          & for each quadrature point.\\
        \hline
        \CodeT{vector}
          & Given ${B_E}$ and a point $x$ in local\\
        \CodeT{ = prepareLocalIntegration(}
          & coordiantes, returns ${\tilde{f}^c[\varphi_i^E]}(x)$ by calling\\
        \CodeT{ localBasefunctionSet}
          & the underlying \CodeT{LocalOperationProvider}.\\
        \CodeT{ localPoint )}
          &\\
        \hline
      \end{tabular}
    \end{class}\theoremEndLine

    \begin{class}[\CodeT{IntegralFunctional< CodimIntegralFunctionals >:LinearFunctional}]
    Represents an integral functional. This is like a \CodeT{CombinedLinearFunctional} (see somewhere), but the
    integration in \CodeT{applyLocal()} is only done once, calling\\
    \CodeT{prepareLocalIntegration()} on each \CodeT{CodimIntegralFunctional}.\\\\
      \begin{tabular}{|l|l|}
        \hline
        \CodeT{number}
          & Inherited from \CodeT{LinearFunctional}.\\
        \CodeT{ = operator( function )}
          & \\
        \hline
        \CodeT{vector}
          & Redefinition of\\
        \CodeT{ = applyLocal( localBasefunctionSet )}
          & \CodeT{LinearFunctional::applyLocal()}.\\
          & Given ${B_E}$, computes ${(f^c[\varphi_i^E])_{i\in I_E}}$ by\\
          & doing a codim c integration for each given\\
          & codim by quadrature and calling\\
          & \CodeT{prepareLocalIntegration()} of each\\
          & \CodeT{CodimIntegralFunctional} for each\\
          & quadrature point.\\
        \hline
      \end{tabular}
    \end{class}\theoremEndLine


\section{Realization of Constraints}

Maybe, we should discuss the general concept first.\\
\\
Example: {\tt ConstraintType::DirichletConstraint dirConstraint( function );}

%(Operator ( Subspace, ProblemInfo ))(u) = Functional


  \bibliographystyle{plain}
  \bibliography{dune-fem-functionals}


\end{document}




